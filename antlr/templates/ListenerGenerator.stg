group ListenerGenerator;

/**
 * Main template for this class.
 */
main(property, methodProperties, variables) ::= <<
package <property.packageName>;

<property.importStatements:importStatement()>
/**
 * This class is auto generated when the parser is generated so that 
 * metrics have a single class for each language that listens of all
 * events that are applicable for all metrics being tested.
 *
 * because all metrics implement the MetricInterface interface, 
 * this means that we can just call the start() method in this to invoke 
 * all methods.
 * 
 * {@link MetricInterface.start() }
 * @author Jack Timblin - U1051575 (via StringTemplate4)
 */
public class BaseListener extends <property.listenerName> {
    
    <variables:declareVariable()>
    /**
     * Initialises all of the metrics that will be used with this listener.
     * @throws core.MetricException
     */
    public BaseListener() throws MetricException {
        metrics = new ArrayList\<MetricInterface>();
        //initialise the metrics.
        try {
            for(String metric : Application.getMetricList()) {
                metrics.add((MetricInterface) Class.forName("metrics."+metric).newInstance());
            }
         } catch (Exception e) {
             throw new MetricException("An error occured initialising all of the metrics.");
         }
    }
    
    <methodProperties:methodBuilder()>
    
}
>>

methodBuilder(methodProperty) ::= <<

/**
 * generated method to call <methodProperty.name> while walking the parse tree.
 * @param context \<p>The context/area of the parse tree that this rule applies to.\</p>
 */
 @Override
 public void <methodProperty.name>(<methodProperty.context> context) {
    //start the metrics.
    for(MetricInterface metric : metrics) {
        //start the metrics evaluation at this event.
        metric.start(context, "<property.sourceLanguage>");
    }
 }
 
>>

importStatement(i) ::= <<
import <i>;

>>

declareVariable(var) ::= <<
private <var.type> <var.name>;

>>